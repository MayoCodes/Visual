<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProCam - Professional Camera</title>
    <link rel="manifest" href="data:application/json,{%22name%22:%22ProCam%22,%22short_name%22:%22ProCam%22,%22description%22:%22Professional%20camera%20and%20photo%20enhancement%20app%22,%22start_url%22:%22/%22,%22display%22:%22fullscreen%22,%22background_color%22:%22%23000000%22,%22theme_color%22:%22%23ff6b35%22,%22icons%22:[{%22src%22:%22data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiBmaWxsPSIjZmY2YjM1Ii8+CjxjaXJjbGUgY3g9IjI1NiIgY3k9IjI1NiIgcj0iMTAwIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIwIiBmaWxsPSJub25lIi8+CjxjaXJjbGUgY3g9IjI1NiIgY3k9IjI1NiIgcj0iNDAiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=%22,%22sizes%22:%22512x512%22,%22type%22:%22image/svg+xml%22}]}">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        .app-container {
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .camera-preview {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #videoPreview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #1a1a1a;
        }

        #canvasPreview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .grid-overlay {
            background-image: 
                linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 33.33% 33.33%;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .grid-overlay.active {
            opacity: 1;
        }

        .top-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
        }

        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .control-btn {
            background: rgba(0,0,0,0.7);
            border: none;
            border-radius: 25px;
            padding: 12px;
            color: white;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            font-size: 18px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            background: rgba(255,107,53,0.8);
            transform: scale(1.1);
        }

        .control-btn.active {
            background: #ff6b35;
        }

        .bottom-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px 20px 40px;
            z-index: 20;
        }

        .main-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .capture-btn {
            width: 80px;
            height: 80px;
            border: 4px solid white;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .capture-btn:active {
            transform: scale(0.95);
        }

        .capture-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .capture-btn.recording::after {
            background: #ff3333;
            border-radius: 8px;
            width: 40px;
            height: 40px;
        }

        .mode-selector {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .mode-btn {
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s;
        }

        .mode-btn.active {
            color: white;
            background: rgba(255,107,53,0.3);
        }

        .side-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .enhancement-controls {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .slider-control {
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            padding: 15px 10px;
            width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 30px;
            height: 120px;
            background: rgba(255,255,255,0.2);
            outline: none;
            border-radius: 15px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b35;
            cursor: pointer;
        }

        .slider-label {
            font-size: 10px;
            text-align: center;
            opacity: 0.8;
        }

        .captured-media {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            z-index: 25;
            transition: transform 0.3s;
        }

        .captured-media:hover {
            transform: scale(1.1);
        }

        .captured-media img,
        .captured-media video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100vh;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            transition: right 0.3s;
            z-index: 30;
            overflow-y: auto;
        }

        .settings-panel.open {
            right: 0;
        }

        .setting-group {
            margin-bottom: 25px;
        }

        .setting-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #ff6b35;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: rgba(255,255,255,0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .switch.active {
            background: #ff6b35;
        }

        .switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .switch.active::after {
            transform: translateX(26px);
        }

        .filter-preview {
            position: absolute;
            bottom: 120px;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            gap: 10px;
            padding: 0 20px;
            overflow-x: auto;
            z-index: 20;
        }

        .filter-item {
            min-width: 60px;
            height: 60px;
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            background-size: cover;
            background-position: center;
            display: flex;
            align-items: flex-end;
            padding: 5px;
            font-size: 10px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }

        .filter-item.active {
            border-color: #ff6b35;
            transform: scale(1.1);
        }

        .focus-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid #ff6b35;
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            opacity: 0;
            transform: scale(1.5);
            transition: all 0.3s;
        }

        .focus-indicator.active {
            opacity: 1;
            transform: scale(1);
        }

        @media (max-width: 480px) {
            .top-controls {
                left: 10px;
                right: 10px;
                top: 10px;
            }
            
            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .capture-btn {
                width: 70px;
                height: 70px;
            }
            
            .enhancement-controls {
                right: 10px;
            }
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top: 3px solid #ff6b35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="camera-preview">
            <video id="videoPreview" autoplay playsinline muted></video>
            <canvas id="canvasPreview"></canvas>
            <div class="overlay grid-overlay" id="gridOverlay"></div>
            <div class="focus-indicator" id="focusIndicator"></div>
        </div>

        <div class="top-controls">
            <div class="control-group">
                <button class="control-btn" id="flashBtn" title="Flash">⚡</button>
                <button class="control-btn" id="gridBtn" title="Grid">⊞</button>
                <button class="control-btn" id="timerBtn" title="Timer">⏱</button>
            </div>
            <div class="control-group">
                <button class="control-btn" id="settingsBtn" title="Settings">⚙</button>
                <button class="control-btn" id="switchCameraBtn" title="Switch Camera">🔄</button>
            </div>
        </div>

        <div class="enhancement-controls">
            <div class="slider-control">
                <div class="slider-label">Brightness</div>
                <input type="range" class="slider" id="brightnessSlider" min="0" max="200" value="100">
            </div>
            <div class="slider-control">
                <div class="slider-label">Contrast</div>
                <input type="range" class="slider" id="contrastSlider" min="0" max="200" value="100">
            </div>
            <div class="slider-control">
                <div class="slider-label">Saturation</div>
                <input type="range" class="slider" id="saturationSlider" min="0" max="200" value="100">
            </div>
        </div>

        <div class="filter-preview" id="filterPreview">
            <div class="filter-item active" data-filter="none">None</div>
            <div class="filter-item" data-filter="vintage">Vintage</div>
            <div class="filter-item" data-filter="bw">B&W</div>
            <div class="filter-item" data-filter="sepia">Sepia</div>
            <div class="filter-item" data-filter="dramatic">Drama</div>
            <div class="filter-item" data-filter="cool">Cool</div>
            <div class="filter-item" data-filter="warm">Warm</div>
        </div>

        <div class="bottom-controls">
            <div class="main-controls">
                <div class="captured-media hidden" id="capturedMedia"></div>
                <button class="capture-btn" id="captureBtn"></button>
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="photo">Photo</button>
                    <button class="mode-btn" data-mode="video">Video</button>
                    <button class="mode-btn" data-mode="portrait">Portrait</button>
                </div>
            </div>
        </div>

        <div class="settings-panel" id="settingsPanel">
            <div class="setting-group">
                <div class="setting-title">Camera Settings</div>
                <div class="setting-item">
                    <span>HDR Mode</span>
                    <div class="switch" id="hdrSwitch"></div>
                </div>
                <div class="setting-item">
                    <span>Image Stabilization</span>
                    <div class="switch active" id="stabilizationSwitch"></div>
                </div>
                <div class="setting-item">
                    <span>Auto Focus</span>
                    <div class="switch active" id="autoFocusSwitch"></div>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-title">Enhancement</div>
                <div class="setting-item">
                    <span>AI Enhancement</span>
                    <div class="switch active" id="aiEnhanceSwitch"></div>
                </div>
                <div class="setting-item">
                    <span>Noise Reduction</span>
                    <div class="switch active" id="noiseReductionSwitch"></div>
                </div>
                <div class="setting-item">
                    <span>Smart HDR</span>
                    <div class="switch" id="smartHdrSwitch"></div>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-title">Quality</div>
                <div class="setting-item">
                    <span>Photo Resolution</span>
                    <select id="photoResolution" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px; border-radius: 5px;">
                        <option value="4k">4K (4096x3072)</option>
                        <option value="2k">2K (2048x1536)</option>
                        <option value="hd" selected>HD (1920x1080)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>Video Quality</span>
                    <select id="videoQuality" style="background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px; border-radius: 5px;">
                        <option value="4k">4K 30fps</option>
                        <option value="1080p60" selected>1080p 60fps</option>
                        <option value="720p">720p 60fps</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="loading hidden" id="loadingOverlay">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <script>
        class ProCameraApp {
            constructor() {
                this.video = document.getElementById('videoPreview');
                this.canvas = document.getElementById('canvasPreview');
                this.ctx = this.canvas.getContext('2d');
                this.stream = null;
                this.isRecording = false;
                this.currentMode = 'photo';
                this.currentFilter = 'none';
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.settings = {
                    brightness: 100,
                    contrast: 100,
                    saturation: 100,
                    hdr: false,
                    stabilization: true,
                    autoFocus: true,
                    aiEnhance: true,
                    noiseReduction: true,
                    smartHdr: false
                };

                this.init();
            }

            async init() {
                try {
                    await this.setupCamera();
                    this.setupEventListeners();
                    this.setupCanvas();
                    this.startPreview();
                    this.registerServiceWorker();
                } catch (error) {
                    console.error('Failed to initialize camera:', error);
                    alert('Unable to access camera. Please check permissions.');
                }
            }

            async setupCamera() {
                const constraints = {
                    video: {
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: true
                };

                this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.video.srcObject = this.stream;
            }

            setupCanvas() {
                const resizeCanvas = () => {
                    this.canvas.width = this.video.videoWidth || 1920;
                    this.canvas.height = this.video.videoHeight || 1080;
                };

                this.video.addEventListener('loadedmetadata', resizeCanvas);
                window.addEventListener('resize', resizeCanvas);
            }

            setupEventListeners() {
                // Capture button
                document.getElementById('captureBtn').addEventListener('click', () => {
                    if (this.currentMode === 'video') {
                        this.toggleRecording();
                    } else {
                        this.capturePhoto();
                    }
                });

                // Mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelector('.mode-btn.active').classList.remove('active');
                        e.target.classList.add('active');
                        this.currentMode = e.target.dataset.mode;
                        this.updateUI();
                    });
                });

                // Enhancement sliders
                document.getElementById('brightnessSlider').addEventListener('input', (e) => {
                    this.settings.brightness = e.target.value;
                    this.applyEnhancements();
                });

                document.getElementById('contrastSlider').addEventListener('input', (e) => {
                    this.settings.contrast = e.target.value;
                    this.applyEnhancements();
                });

                document.getElementById('saturationSlider').addEventListener('input', (e) => {
                    this.settings.saturation = e.target.value;
                    this.applyEnhancements();
                });

                // Filter selection
                document.querySelectorAll('.filter-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        document.querySelector('.filter-item.active').classList.remove('active');
                        e.target.classList.add('active');
                        this.currentFilter = e.target.dataset.filter;
                        this.applyEnhancements();
                    });
                });

                // Control buttons
                document.getElementById('gridBtn').addEventListener('click', this.toggleGrid.bind(this));
                document.getElementById('settingsBtn').addEventListener('click', this.toggleSettings.bind(this));
                document.getElementById('switchCameraBtn').addEventListener('click', this.switchCamera.bind(this));

                // Settings switches
                document.querySelectorAll('.switch').forEach(sw => {
                    sw.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        const settingName = e.target.id.replace('Switch', '').replace(/([A-Z])/g, (match) => match.toLowerCase());
                        this.settings[settingName] = e.target.classList.contains('active');
                    });
                });

                // Touch focus
                this.video.addEventListener('click', this.handleFocusTouch.bind(this));
            }

            startPreview() {
                const render = () => {
                    if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                        this.applyEnhancements();
                    }
                    requestAnimationFrame(render);
                };
                render();
            }

            applyEnhancements() {
                if (!this.ctx || this.video.readyState !== this.video.HAVE_ENOUGH_DATA) return;

                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;

                // Apply brightness, contrast, and saturation
                for (let i = 0; i < data.length; i += 4) {
                    let r = data[i];
                    let g = data[i + 1];
                    let b = data[i + 2];

                    // Brightness
                    const brightnessFactor = this.settings.brightness / 100;
                    r *= brightnessFactor;
                    g *= brightnessFactor;
                    b *= brightnessFactor;

                    // Contrast
                    const contrastFactor = this.settings.contrast / 100;
                    r = ((r - 128) * contrastFactor) + 128;
                    g = ((g - 128) * contrastFactor) + 128;
                    b = ((b - 128) * contrastFactor) + 128;

                    // Saturation
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    const satFactor = this.settings.saturation / 100;
                    r = gray + (r - gray) * satFactor;
                    g = gray + (g - gray) * satFactor;
                    b = gray + (b - gray) * satFactor;

                    // Apply filters
                    this.applyFilter(data, i, r, g, b);
                }

                this.ctx.putImageData(imageData, 0, 0);

                // Apply AI enhancement if enabled
                if (this.settings.aiEnhance) {
                    this.applyAIEnhancement();
                }
            }

            applyFilter(data, index, r, g, b) {
                switch (this.currentFilter) {
                    case 'bw':
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        data[index] = data[index + 1] = data[index + 2] = gray;
                        break;
                    case 'sepia':
                        data[index] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        data[index + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        data[index + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        break;
                    case 'vintage':
                        data[index] = Math.min(255, r * 1.1);
                        data[index + 1] = Math.min(255, g * 0.9);
                        data[index + 2] = Math.min(255, b * 0.8);
                        break;
                    case 'dramatic':
                        data[index] = Math.min(255, r * 1.2);
                        data[index + 1] = Math.min(255, g * 1.1);
                        data[index + 2] = Math.min(255, b * 0.9);
                        break;
                    case 'cool':
                        data[index] = Math.min(255, r * 0.9);
                        data[index + 1] = Math.min(255, g * 1.0);
                        data[index + 2] = Math.min(255, b * 1.2);
                        break;
                    case 'warm':
                        data[index] = Math.min(255, r * 1.1);
                        data[index + 1] = Math.min(255, g * 1.05);
                        data[index + 2] = Math.min(255, b * 0.9);
                        break;
                    default:
                        data[index] = Math.max(0, Math.min(255, r));
                        data[index + 1] = Math.max(0, Math.min(255, g));
                        data[index + 2] = Math.max(0, Math.min(255, b));
                }
            }

            applyAIEnhancement() {
                // Simulated AI enhancement using advanced image processing
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const data = imageData.data;

                // Edge enhancement
                this.enhanceEdges(data);

                // Noise reduction
                if (this.settings.noiseReduction) {
                    this.reduceNoise(data);
                }

                this.ctx.putImageData(imageData, 0, 0);
            }

            enhanceEdges(data) {
                // Simple edge enhancement algorithm
                const width = this.canvas.width;
                const height = this.canvas.height;
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Sobel operator for edge detection
                        const sobelX = -data[idx - 4] + data[idx + 4] - 2 * data[(y - 1) * width * 4 + x * 4] + 2 * data[(y + 1) * width * 4 + x * 4];
                        const sobelY = -data[(y - 1) * width * 4 + (x - 1) * 4] - 2 * data[(y - 1) * width * 4 + x * 4] - data[(y - 1) * width * 4 + (x + 1) * 4] + data[(y + 1) * width * 4 + (x - 1) * 4] + 2 * data[(y + 1) * width * 4 + x * 4] + data[(y + 1) * width * 4 + (x + 1) * 4];
                        
                        const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
                        
                        if (magnitude > 50) {
                            data[idx] = Math.min(255, data[idx] + magnitude * 0.1);
                            data[idx + 1] = Math.min(255, data[idx + 1] + magnitude * 0.1);
                            data[idx + 2] = Math.min(255, data[idx + 2] + magnitude * 0.1);
                        }
                    }
                }
            }

            reduceNoise(data) {
                // Simple bilateral filter for noise reduction
                const width = this.canvas.width;
                const height = this.canvas.height;
                const original = new Uint8ClampedArray(data);

                for (let y = 2; y < height - 2; y++) {
                    for (let x = 2; x < width - 2; x++) {
                        const idx = (y * width + x) * 4;
                        let rSum = 0, gSum = 0, bSum = 0, weightSum = 0;

                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                const spatialDist = dx * dx + dy * dy;
                                const colorDist = Math.abs(original[idx] - original[nIdx]) + Math.abs(original[idx + 1] - original[nIdx + 1]) + Math.abs(original[idx + 2] - original[nIdx + 2]);
                                const weight = Math.exp(-(spatialDist / 8 + colorDist / 100));

                                rSum += original[nIdx] * weight;
                                gSum += original[nIdx + 1] * weight;
                                bSum += original[nIdx + 2] * weight;
                                weightSum += weight;
                            }
                        }

                        data[idx] = rSum / weightSum;
                        data[idx + 1] = gSum / weightSum;
                        data[idx + 2] = bSum / weightSum;
                    }
                }
            }

            async capturePhoto() {
                this.showLoading(true);

                try {
                    // Create high-quality capture
                    const captureCanvas = document.createElement('canvas');
                    const captureCtx = captureCanvas.getContext('2d');
                    
                    captureCanvas.width = this.canvas.width;
                    captureCanvas.height = this.canvas.height;
                    
                    // Draw current enhanced frame
                    captureCtx.drawImage(this.canvas, 0, 0);

                    // Convert to blob with high quality
                    const blob = await new Promise(resolve => {
                        captureCanvas.toBlob(resolve, 'image/jpeg', 0.95);
                    });

                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `procam_photo_${Date.now()}.jpg`;
                    a.click();
                    URL.revokeObjectURL(url);

                    // Show thumbnail
                    this.showCapturedMedia(url, 'image');

                } catch (error) {
                    console.error('Photo capture failed:', error);
                    alert('Failed to capture photo');
                } finally {
                    this.showLoading(false);
                }
            }

            async toggleRecording() {
                if (!this.isRecording) {
                    await this.startRecording();
                } else {
                    this.stopRecording();
                }
            }

            async startRecording() {
                try {
                    this.recordedChunks = [];
                    
                    // Create MediaRecorder with enhanced canvas stream
                    const canvasStream = this.canvas.captureStream(30);
                    const audioTrack = this.stream.getAudioTracks()[0];
                    if (audioTrack) {
                        canvasStream.addTrack(audioTrack);
                    }

                    this.mediaRecorder = new MediaRecorder(canvasStream, {
                        mimeType: 'video/webm;codecs=vp9,opus',
                        videoBitsPerSecond: 8000000
                    });

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.handleVideoSave();
                    };

                    this.mediaRecorder.start(1000);
                    this.isRecording = true;
                    this.updateUI();

                } catch (error) {
                    console.error('Recording start failed:', error);
                    alert('Failed to start recording');
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.updateUI();
                }
            }

            handleVideoSave() {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `procam_video_${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);

                this.showCapturedMedia(url, 'video');
            }

            showCapturedMedia(url, type) {
                const capturedMedia = document.getElementById('capturedMedia');
                capturedMedia.innerHTML = type === 'image' ? 
                    `<img src="${url}" alt="Captured">` : 
                    `<video src="${url}" muted></video>`;
                capturedMedia.classList.remove('hidden');
            }

            updateUI() {
                const captureBtn = document.getElementById('captureBtn');
                captureBtn.classList.toggle('recording', this.isRecording);
            }

            toggleGrid() {
                const gridOverlay = document.getElementById('gridOverlay');
                gridOverlay.classList.toggle('active');
            }

            toggleSettings() {
                const settingsPanel = document.getElementById('settingsPanel');
                settingsPanel.classList.toggle('open');
            }

            async switchCamera() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter(device => device.kind === 'videoinput');
                    
                    if (videoDevices.length > 1) {
                        // Switch to next camera
                        const currentDevice = this.stream.getVideoTracks()[0].getSettings().deviceId;
                        const currentIndex = videoDevices.findIndex(device => device.deviceId === currentDevice);
                        const nextIndex = (currentIndex + 1) % videoDevices.length;
                        
                        this.stream.getTracks().forEach(track => track.stop());
                        
                        const constraints = {
                            video: {
                                deviceId: { exact: videoDevices[nextIndex].deviceId },
                                width: { ideal: 1920 },
                                height: { ideal: 1080 }
                            },
                            audio: true
                        };
                        
                        this.stream = await navigator.mediaDevices.getUserMedia(constraints);
                        this.video.srcObject = this.stream;
                    }
                } catch (error) {
                    console.error('Camera switch failed:', error);
                }
            }

            handleFocusTouch(event) {
                const rect = this.video.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const focusIndicator = document.getElementById('focusIndicator');
                focusIndicator.style.left = `${x - 40}px`;
                focusIndicator.style.top = `${y - 40}px`;
                focusIndicator.classList.add('active');
                
                setTimeout(() => {
                    focusIndicator.classList.remove('active');
                }, 1000);
            }

            showLoading(show) {
                const loadingOverlay = document.getElementById('loadingOverlay');
                loadingOverlay.classList.toggle('hidden', !show);
            }

            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register(
                            `data:application/javascript,${encodeURIComponent(this.getServiceWorkerCode())}`
                        );
                        console.log('Service Worker registered:', registration);
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }

            getServiceWorkerCode() {
                return `
                const CACHE_NAME = 'procam-v1';
                const urlsToCache = ['/'];
                
                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(urlsToCache))
                    );
                });
                
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => response || fetch(event.request))
                    );
                });
                `;
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new ProCameraApp();
        });

        // Handle installation prompt on DOM loading standard to initiallize pwa
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
        });
    </script>
</body>
</html>